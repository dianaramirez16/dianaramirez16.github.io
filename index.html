<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Personal Portfolio</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <!-- Fix for older versions of IE -->
    <!--[if lt IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
    <![endif]-->
    <link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
    <!-- Add p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Year of the Dragon</h1>
        <br>
        <h4>Click the dragons for more art</h4>
      </header>
      
      <!-- Placeholder for p5.js sketch -->
      <div id="myCanvas" style="border:5px solid tomato; width:1010px; height:500;">
        
      </div>
      
    </div>

    <!-- Add custom p5.js sketch -->
    <script>
      let snakes = [];

      function setup() {
        const canvas = createCanvas(1000, 490);
        canvas.parent('myCanvas');
        background(255);

        // Create multiple snakes
        let l = getOddLength();
        for (let i = 0; i < l; i++) {
          snakes.push(new Snake(random(width), random(height), l));
          l = getOddLength();
        }
      }

      function getOddLength() {
        let l = random(3, 13);
        if (l % 2 == 1) {
          l += 1;
        }
        return l;
      }

      function draw() {
        background(255, 255, 255, 25);

        // Update and display each snake
        for (let snake of snakes) {
          snake.move();
          snake.display();
        }
        push();
        head(120, 120); // Call head, passing x and y
        pop();
        head(mouseX, mouseY);
      }

      class Ball {
        constructor(x, y, r) {
          this.x = x;
          this.y = y;
          this.r = r;
        }

        display(color) {
          noStroke();
          fill(color);
          //ellipse(this.x, this.y, this.r / 1.5);
          head(this.x,this.y)
        }
      }

      class Snake {
        constructor(x, y, length) {
          this.segments = [];
          this.color = color(random(240, 255), random(0, 50), random(0, 50));
          for (let i = 0; i < length; i++) {
            this.segments.push(new Ball(x - i * 15, y, 16));
          }
          this.xSpeed = random(1, 3);
          this.ySpeed = random(-1, 1);
          this.zigzagAngle = 0;
        }

        move() {
          this.zigzagAngle += 0.1;
          const dx = this.xSpeed;
          const dy = this.ySpeed + sin(this.zigzagAngle) * 2;

          // Move the head of the snake
          this.segments[0].x += dx;
          this.segments[0].y += dy;

          // Update the positions of the other segments to follow the head
          for (let i = 1; i < this.segments.length; i++) {
            const prev = this.segments[i - 1];
            const curr = this.segments[i];
            const angle = atan2(prev.y - curr.y, prev.x - curr.x);
            curr.x = prev.x - cos(angle) * 15;
            curr.y = prev.y - sin(angle) * 15;
          }

          // Bounce off edges
          if (this.segments[0].x < 0 || this.segments[0].x > width) {
            this.xSpeed *= -1;
          }
          if (this.segments[0].y < 0 || this.segments[0].y > height) {
            this.ySpeed *= -1;
          }
        }

        display() {
          for (let segment of this.segments) {
            segment.display(this.color);
          }
        }
      }

function head(x, y) {
  fill(255, 0, 0); // Set the fill color to red
  stroke('pink')
  line(0,y,800,y);
  noStroke();      // Disable stroke (borders)
  
  // Draw the left ellipse rotated by -10 degrees (counterclockwise)
  
  push();
  translate(x, y); // Move to the center of the ellipse
  rotate(radians(-10)); // Rotate by -10 degrees
  ellipse(0, 0, 12 * 0.7, 30); // Draw the ellipse at the rotated position, scaled by 0.7
  pop();

  // Draw the right ellipse rotated by 10 degrees (clockwise)
  push();
  translate(x + 5, y); // Move to the center of the ellipse
  rotate(radians(10)); // Rotate by 10 degrees
  ellipse(0, 0, 12 * 0.7, 30 ); // Draw the ellipse at the rotated position, scaled by 0.7
  pop();

  circle(x + 2, y - 6, 14); // Draw the central circle (nose), scaled by 0.7

  // Draw the circles below the ellipses
  ellipse(x - 3, y + 10, 18 * 0.7, 30 ); // Left circle, scaled by 0.7

  // Draw the arc for the left side of the mouth
  arc(x - 7, y + 4, 26 * 0.7, 48 * 0.7, radians(280), radians(132));

  // Draw the arc for the right side of the mouth
  arc(x + 13, y + 4, 24 * 0.7, 47 * 0.7, radians(60), radians(258));

  ellipse(x + 9, y + 11, 18 * 0.7, 30); // Right circle, scaled by 0.7

  // Horns
  push();
  translate(x-11, y+32);
  rotate(radians(18));
  rect(-6, -12.5, 7, 17);
  pop();

  push();
  translate(x-24, y+44); 
  rotate(radians(-15));
  rect(44, -12.5, 5, 17);
  pop();
   //fill('blue')
  // Draw the horn on the left side
  drawHorn(x -68, y - 30, 13, false,1); // Left side horn
  drawHorn(x-50, y-40, 17, false,.8); //inner left
  
  drawHorn(x+11, y-20, 9, true,1); //outer right
  drawHorn(x-3, y-27, 11, true,.4); //inner right
}
function drawHorn(x, y, angle, flip, scale) {
  let scaleFactor = 0.8 * scale; // Adjust the scaling factor based on the `scale` parameter
  
  let horn_pox = x - 10;
  let horn2_pox = x + 11;

  // Protect the transformations with push() and pop() to avoid affecting the other shapes
  
  // Draw the first curly shape near the left horn (or flipped)
  push(); // Save current state
  translate(horn_pox + 18, y + 4); // Translate to the correct position
  if (flip){
    drawCurly(-27, 17, angle, 0.5, true, 'red', 3); 
    
  } else {// Apply flip only to this shape
    drawCurly(0, 0, angle - 5, 0.75, false, 'red', 4);
  }// Draw the curly shape
  pop(); // Restore original state
  
  // Draw the second curly shape near the right horn (or flipped)
  push(); // Save current state
  translate(horn2_pox, y - 20); // Translate to the correct position
  if (flip){
    drawCurly(-47, 0, angle+6, 1, true, 'red', 2.5); 
    
  } else {
    drawCurly(0, 0, angle + 5, 1, false, 'red', 2.5); // Draw the curly shape
  }pop(); // Restore original state
  
  // Optionally draw other shapes (e.g., another curly shape)
  // drawCurly(x-4, y-32, angle+4, 1.1, false, 255, 255, 2)
}
function drawCurly(x, y, angle, scaleFactor = 2, flip = false, strokeColor = 'blue', strokeWidth) {
  let points = [68, 45, 69, 52, 68, 55, 65, 61.5, 64, 66, 66, 70.5,
                70, 77, 71, 83, 71, 89];

  // Scale points
  for (let i = 0; i < points.length; i++) {
    points[i] *= scaleFactor;
  }

  // Adjust position
  for (let i = 0; i < points.length; i += 2) {
    points[i] += x;
    points[i + 1] += y;
  }

  // Apply rotation and flip
  let rotatedPoints = [];
  for (let i = 0; i < points.length; i += 2) {
    let xPos = points[i];
    let yPos = points[i + 1];
    let rotatedX = xPos * cos(radians(angle)) - yPos * sin(radians(angle));
    let rotatedY = xPos * sin(radians(angle)) + yPos * cos(radians(angle));
    if (flip) rotatedX = -rotatedX; // Flip the x-coordinate if necessary
    rotatedPoints.push(rotatedX, rotatedY);
  }

  // Set colors and stroke
  noFill()
  stroke(strokeColor);
  strokeWeight(int(strokeWidth));

  // Draw shape
  push();
  beginShape();
  for (let i = 0; i < rotatedPoints.length; i += 2) {
    curveVertex(rotatedPoints[i], rotatedPoints[i + 1]);
  }
  endShape();
  pop();
}
    </script>

    <script src="js/script.js"></script>
  </body>
</html>
