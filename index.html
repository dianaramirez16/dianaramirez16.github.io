<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Personal Portfolio</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <!-- Fix for older versions of IE -->
    <!--[if lt IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
    <![endif]-->
    <link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
    <!-- Add p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Year of the Dragon</h1>
        <br>
        <h4>Click the dragons for more art</h4>
      </header>
      
      <!-- Placeholder for p5.js sketch -->
      <div id="myCanvas" style="border:5px solid tomato; width:1010px; height:500;">
        
      </div>
      
    </div>

    <!-- Add custom p5.js sketch -->
    <script>
      let snakes = [];

      function setup() {
        const canvas = createCanvas(1000, 490);
        canvas.parent('myCanvas');
        background(255);

        // Create multiple snakes
        let l = getOddLength();
        for (let i = 0; i < l; i++) {
          snakes.push(new Snake(random(width), random(height), l));
          l = getOddLength();
        }
      }

      function getOddLength() {
        let l = random(3, 13);
        if (l % 2 == 1) {
          l += 1;
        }
        return l;
      }

      function draw() {
        background(255, 255, 255, 25);

        // Update and display each snake
        for (let snake of snakes) {
          snake.move();
          snake.display();
        }
        push();
        head(120, 120); // Call head, passing x and y
        pop();
        head(mouseX, mouseY);
      }

      class Ball {
        constructor(x, y, r) {
          this.x = x;
          this.y = y;
          this.r = r;
        }

        display(color) {
          noStroke();
          fill(color);
          ellipse(this.x, this.y, this.r / 1.5);
        }
      }

      class Snake {
        constructor(x, y, length) {
          this.segments = [];
          this.color = color(random(240, 255), random(0, 50), random(0, 50));
          for (let i = 0; i < length; i++) {
            this.segments.push(new Ball(x - i * 15, y, 16));
          }
          this.xSpeed = random(1, 3);
          this.ySpeed = random(-1, 1);
          this.zigzagAngle = 0;
        }

        move() {
          this.zigzagAngle += 0.1;
          const dx = this.xSpeed;
          const dy = this.ySpeed + sin(this.zigzagAngle) * 2;

          // Move the head of the snake
          this.segments[0].x += dx;
          this.segments[0].y += dy;

          // Update the positions of the other segments to follow the head
          for (let i = 1; i < this.segments.length; i++) {
            const prev = this.segments[i - 1];
            const curr = this.segments[i];
            const angle = atan2(prev.y - curr.y, prev.x - curr.x);
            curr.x = prev.x - cos(angle) * 15;
            curr.y = prev.y - sin(angle) * 15;
          }

          // Bounce off edges
          if (this.segments[0].x < 0 || this.segments[0].x > width) {
            this.xSpeed *= -1;
          }
          if (this.segments[0].y < 0 || this.segments[0].y > height) {
            this.ySpeed *= -1;
          }
        }

        display() {
          for (let segment of this.segments) {
            segment.display(this.color);
          }
        }
      }

      function head(x, y) {
        fill(255, 0, 0); // Set the fill color to red
        noStroke();      // Disable stroke (borders)

        // Draw the left ellipse rotated by -10 degrees (counterclockwise)
        push();
        translate(x, y); // Move to the center of the ellipse
        rotate(radians(-10)); // Rotate by -10 degrees
        ellipse(0, 0, 12 * 0.7, 30); // Draw the ellipse at the rotated position, scaled by 0.7
        pop();

        // Draw the right ellipse rotated by 10 degrees (clockwise)
        push();
        translate(x + 5, y); // Move to the center of the ellipse
        rotate(radians(10)); // Rotate by 10 degrees
        ellipse(0, 0, 12 * 0.7, 30 ); // Draw the ellipse at the rotated position, scaled by 0.7
        pop();

        circle(x + 2, y - 6, 14); // Draw the central circle (nose), scaled by 0.7

        // Draw the circles below the ellipses
        ellipse(x - 3, y + 10, 18 * 0.7, 30 ); // Left circle, scaled by 0.7

        // Draw the arc for the left side of the mouth
        arc(x - 7, y + 4, 26 * 0.7, 48 * 0.7, radians(280), radians(132));

        // Draw the arc for the right side of the mouth
        arc(x + 13, y + 4, 24 * 0.7, 47 * 0.7, radians(60), radians(258));

        ellipse(x + 9, y + 11, 18 * 0.7, 30); // Right circle, scaled by 0.7

        // Horns
        push();
        translate(308, 354);
        rotate(radians(17));
        rect(-5, -12.5, 6, 15);
        pop();

        push();
        translate(298, 368);
        rotate(radians(-17));
        rect(45, -12.5, 6, 15);
        pop();

        drawHorn(x - 50, y - 14, 15); // Calling the drawHorn function
      }

      function drawHorn(x, y, angle) {
        let scaleFactor = 0.75; // Scaling factor
        
        fill('red');
        // Draw the circle at the new position, considering the offset, scale, and rotation
        let rotatedCircleX = 72 * scaleFactor + x;
        let rotatedCircleY = 65 * scaleFactor + y;

        // Apply rotation to the circle's center position
        let circleX = rotatedCircleX * cos(radians(angle)) - rotatedCircleY * sin(radians(angle));
        let circleY = rotatedCircleX * sin(radians(angle)) + rotatedCircleY * cos(radians(angle));

        circle(circleX + 2, circleY + 1, 13 * scaleFactor);
        
        // Calling drawCurly after the horn
        drawCurly(x, y, angle);
      }

      function drawCurly(x, y, angle) {
        let points = [67, 45, 69, 52, 69, 55, 65, 61.5, 64, 66, 66, 70.5,
                      70, 77, 71, 83, 70, 89];

        // Scaling factor to scale the drawing by 25% (75% of the original size)
        let scaleFactor = 0.75;

        // Scale down the points
        for (let i = 0; i < points.length; i++) {
          points[i] *= scaleFactor;  // Scale each x and y coordinate by 0.75
        }

        // Adjust each point by the x and y offsets to move the shape
        for (let i = 0; i < points.length; i += 2) {
          points[i] += x;     // Add x to all x-coordinates
          points[i + 1] += y; // Add y to all y-coordinates
        }

        // Apply rotation to each point
        let rotatedPoints = [];
        for (let i = 0; i < points.length; i += 2) {
          let xPos = points[i];
          let yPos = points[i + 1];

          // Apply rotation using the angle in radians
          let rotatedX = xPos * cos(radians(angle)) - yPos * sin(radians(angle));
          let rotatedY = xPos * sin(radians(angle)) + yPos * cos(radians(angle));

          rotatedPoints.push(rotatedX);
          rotatedPoints.push(rotatedY);
        }

        noFill();
        stroke('blue');
        strokeWeight(3);

        push(); // Save the current transformation state

        beginShape(); // Begin drawing the curve

        // Loop through the rotated array two elements at a time (x, y pairs)
        for (let i = 0; i < rotatedPoints.length; i += 2) {
          let xPos = rotatedPoints[i];
          let yPos = rotatedPoints[i + 1];
          curveVertex(xPos, yPos); // Add each point to the curve
        }

        endShape();

        pop();
      }
    </script>

    <script src="js/script.js"></script>
  </body>
</html>
